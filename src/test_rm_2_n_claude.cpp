/* This code is generated by Claude 3.5 Sonnet. 

This is a C++ implementation of the sums_RM2 function from the original Python codes of R. Fourquet and C. Tavernier in their article "List decoding of second order Reedâ€“Muller and its covering radius implications.".

The original Python codes can be found at the Phd thesis of R. Fourquet. 

The function sums_RM2 takes a vector of t, which is the truth table of a Boolean function, and an epsilon value. 

It returns a list of solutions, where each solution is a pair of a quadratic function Quadratic and an important value. 

The most nearest quadratic function to the given truth table is the one with the maximum absolute value of the important value. */


#include <vector>
#include <string>
#include <map>
#include <cmath>
#include <sstream>
#include <algorithm>
#include <unordered_map>
#include <iostream>
#include <functional>
#include <cstdint>

double max_abs_value = 0;

// Helper function to get bits
std::vector<int> bits(int d) {
    std::vector<int> bs;
    int b = 0;
    while (d) {
        if (d & 1) 
            bs.push_back(b);
        d >>= 1;
        b++;
    }
    return bs;
}

class Linear {
private:
    int _int;

public:
    Linear(int value = 0) : _int(value) {}

    std::string toString() const {
        if (_int == 0) return "0";
        std::vector<int> bit_positions = bits(_int);
        std::stringstream ss;
        bool first = true;
        for (int i : bit_positions) {
            if (!first) ss << "+";
            ss << "x" << i;
            first = false;
        }
        return ss.str();
    }

    int getInt() const { return _int; }
};

class Quadratic {
private:
    std::map<int, int> lins;
    Linear lin;

public:
    Quadratic() : lin(0) {}
    
    Quadratic(const Quadratic& src) : 
        lins(src.lins), 
        lin(src.lin) {}

    int coeff(int i) const {
        auto it = lins.find(i);
        return (it != lins.end()) ? it->second : 0;
    }

    void set_coeff(int i, int lin) {
        lins[i] = lin;
    }

    void set_linear(int value) {
        lin = Linear(value);
    }

    Linear getLinear() const {
        return lin;
    }

    std::string toString() const {
        std::stringstream ss;
        ss << lin.toString();
        for (const auto& pair : lins)
            if (pair.second != 0) 
                ss << "+x" << pair.first << "*(" << Linear(pair.second).toString() << ")";
        return ss.str();
    }
};

// Vector operations equivalent to numpy functions
std::vector<double> maximums_section_slow(const std::vector<double>& s0, const std::vector<double>& s1) {
    std::vector<double> result;
    int l = s0.size();
    
    for (int coeff = 0; coeff < l; coeff++) {
        double max_val = -std::numeric_limits<double>::infinity();
        for (int lin = 0; lin < l; lin++) 
            max_val = std::max(max_val, std::abs(s0[lin]) + std::abs(s1[lin ^ coeff]));
        result.push_back(max_val);
    }
    return result;
}

// 3D array structure for FFT operations
class Array3D {
private:
    std::vector<double> data;

public:
    int dim1, dim2, dim3;
    Array3D(int d1, int d2, int d3) : dim1(d1), dim2(d2), dim3(d3) {
        data.resize(d1 * d2 * d3);
    }

    double& operator()(int i, int j, int k) {
        return data[i * dim2 * dim3 + j * dim3 + k];
    }
    
    const double& operator()(int i, int j, int k) const {
        return data[i * dim2 * dim3 + j * dim3 + k];
    }
    
    // Reshape functionality
    void reshape(int new_dim1, int new_dim2, int new_dim3) {
        if (new_dim1 * new_dim2 * new_dim3 != data.size()) 
            throw std::runtime_error("Invalid reshape dimensions");
        dim1 = new_dim1;
        dim2 = new_dim2;
        dim3 = new_dim3;
    }
};

Array3D FFT_one_step(const Array3D& F, int coeff) {
    int dims[3] = {F.dim1, 2, F.dim3};
    Array3D Fi(dims[0], dims[1], dims[2]);

    for (int s = 0; s < dims[0]; s++) {
        for (int lin = 0; lin < dims[2]; lin++) {
            double a = F(s, 0, lin);
            double b = F(s, 1, lin ^ coeff);
            Fi(s, 0, lin) = a + b;
            Fi(s, 1, lin) = a - b;
        }
    }

    if (dims[0] == 1) 
        Fi.reshape(1, 1, dims[2] * 2);
    else 
        Fi.reshape(dims[0] / 2, 2, dims[2] * 2);
    return Fi;
}

std::vector<double> maximums_section(const std::vector<double>& s0, const std::vector<double>& s1) {
    if (s0.size() < 8) 
        return maximums_section_slow(s0, s1);

    std::unordered_map<double, std::vector<int>> P0, P1;
    int l = s0.size();
    std::vector<double> maxs(l, 0);
    std::vector<bool> filled(l, false);
    int remains = l;

    // Build P0 and P1
    for (int lin = 0; lin < l; lin++) {
        P0[std::abs(s0[lin])].push_back(lin);
        P1[std::abs(s1[lin])].push_back(lin);
    }

    double max0 = *std::max_element(s0.begin(), s0.end());
    double max1 = *std::max_element(s1.begin(), s1.end());

    for (double z = max0 + max1; z >= 0; z -= 4) {
        for (double x = max0; x > z - max1 - 1; x -= 4) {
            for (int u : P0[x]) {
                for (int v : P1[z - x]) {
                    if (!filled[u ^ v]) {
                        maxs[u ^ v] = z;
                        filled[u ^ v] = true;
                        remains--;
                        if (remains == 0) 
                            return maxs;
                    }
                }
            }
        }
    }
    return maxs;
}

// Main sums_RM2 function would require significant modification due to Python's
// generator syntax and numpy array handling. Here's a simplified version:


// Solution structure to hold results
struct Solution {
    Quadratic quad;
    double value;
    
    Solution(const Quadratic& q, double v) : quad(q), value(v) {}
};

// Helper function to create a 3D array from a vector
Array3D vector_to_3d(const std::vector<double>& t) {
    int size = t.size();
    Array3D result(size/2, 2, 1);
    
    for (int i = 0; i < size/2; i++) 
        for (int j = 0; j < 2; j++) 
            result(i, j, 0) = std::pow(-1.0, t[i*2 + j]);
    return result;
}

std::vector<Solution> sums_RM2(const std::vector<double>& t, double eps) {
    double E = t.size() * eps; // non-normalized epsilon (sums threshold)
    std::vector<Solution> solutions;
    
    // Lambda function for searching suffixes
    std::function<void(Quadratic&, int, const Array3D&)> search_suffixes;
    
    search_suffixes = [&](Quadratic& quad, int i, const Array3D& F) {
        // Check if we're not at the final step
        if (F.dim1 > 1 || F.dim2 > 1) {
            // Calculate sums using maximums_section
            std::vector<double> sums(F.dim3 * 2, 0.0);
            
            // Lambda for processing sections
            auto process_section = [&](int section) {
                std::vector<double> s0(F.dim3), s1(F.dim3);
                for (int j = 0; j < F.dim3; j++) {
                    s0[j] = F(section, 0, j);
                    s1[j] = F(section, 1, j);
                }
                auto section_maxs = maximums_section(s0, s1);
                for (size_t k = 0; k < section_maxs.size(); k++) 
                    sums[k] += section_maxs[k];
            };
            
            // Process all sections
            for (int section = 0; section < F.dim1; section++) 
                process_section(section);
            
            // Lambda for checking threshold
            auto check_threshold = [&](int lin) {
                return sums[lin] >= E;
            };
            
            // Process coefficients that meet threshold
            for (int lin = 0; lin < sums.size(); lin++) {
                if (check_threshold(lin)) {
                    quad.set_coeff(i-1, lin);
                    Array3D Fnext = FFT_one_step(F, lin);
                    search_suffixes(quad, i+1, Fnext);
                }
            }
        } else {
            // Final step - process linear part
            auto process_final = [&](int lin) {
                if (std::abs(F(0, 0, lin)) >= E) {
                    Quadratic new_quad(quad);  // Make a copy
                    new_quad.set_linear(lin);
                    double value = F(0, 0, lin) / static_cast<double>(t.size());
                    if (std::abs(value) > max_abs_value) 
                        max_abs_value = std::abs(value);
                    solutions.emplace_back(new_quad, value);
                }
            };
            
            for (int lin = 0; lin < F.dim3; lin++) 
                process_final(lin);
        }
    };
    
    // Initial setup
    Array3D initial_F = vector_to_3d(t);
    Quadratic initial_quad;
    
    // Start the recursive search
    search_suffixes(initial_quad, 1, initial_F);
    
    return solutions;
}

// Helper function to print solutions
void print_solutions(const std::vector<Solution>& solutions) {
    for (const auto& sol : solutions) {
        std::cout << "Quadratic: " << sol.quad.toString() << "\n";
        // std::cout << "Linear: " << sol.quad.getLinear().toString() << "\n";
        std::cout << "Value: " << sol.value << "\n";
        std::cout << "-------------------\n";
    }
}





int main() {
    std::vector<double> test_data = { 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1,
0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0,
1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0,
1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1,
0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1};
    double epsilon = 0.3;
    
    auto solutions = sums_RM2(test_data, epsilon);
    // print_solutions(solutions);
    printf("Max abs value: %f\n", max_abs_value);
    
    // return the index of the max abs value
    for (int i = 0; i < solutions.size(); i++) {
        if (std::abs(solutions[i].value) == max_abs_value) {
            std::cout << "Quadratic function:" << solutions[i].quad.toString() << std::endl;
            break;
        }
    }
}




// tt:= [];
// for x7,x6,x5,x4,x3,x2,x1,x0 in GF(2) do 
//     Append(~tt,x0+x2+x3+x5+x2*(x0+x1)+x3*(x2)+x5*(x0+x2)+x6*(x1+x2)+x7*(x0+x2+x3+x5));
// end for;



// n:=8;
// Z:=Integers();
// F<v>:=GF(2,n);
// P<x>:=PolynomialRing(F);
// res:=[Trace(x^(2^8-2)):x in F];
// int_res:=[&+[Z!Eltseq(x)[i]*2^(i-1):i in [1..1]]:x in res];
// int_x:=[&+[Z!Eltseq(x)[i]*2^(i-1):i in [1..n]]:x in F];
// res_final:=[1..#int_res];
// for i in [1..#int_x] do
// res_final[int_x[i]+1]:=int_res[i];
// end for;